/*
Copyright 2025  The Hyperlight Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

mod build_files;

use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};
use std::{env, fs};

use anyhow::{Context, Result, bail};
use build_files::{LIBC_FILES, LIBC_FILES_X86, LIBM_FILES, LIBM_FILES_X86};

fn copy_includes<P: AsRef<Path>, Q: AsRef<Path> + std::fmt::Debug>(
    include_dir: P,
    base: Q,
) -> Result<()> {
    let entries =
        fs::read_dir(&base).with_context(|| format!("could not open include dir {:?}", base))?;

    for entry in entries {
        let entry = entry.with_context(|| format!("could not read include dir {:?}", base))?;
        let src = entry.path();
        let dst = include_dir.as_ref().join(entry.file_name());
        let kind = entry
            .file_type()
            .with_context(|| format!("could not find type of {:?}", src))?;

        if kind.is_dir() {
            fs::create_dir_all(&dst)
                .with_context(|| format!("could not create include dir {:?}", &dst))?;
            copy_includes(&dst, src)?;
        } else if Some(std::ffi::OsStr::new("h")) == src.extension() {
            fs::copy(&src, &dst).with_context(|| format!("could not copy header {:?}", &src))?;
        }
    }

    Ok(())
}

fn detect_cc_feature(test_code: &str) -> Result<bool> {
    let cc = std::env::var("HYPERLIGHT_GUEST_clang").unwrap_or_else(|_| "clang".into());

    let mut cmd = Command::new(&cc)
        .arg("-std=c18")
        .arg("-x")
        .arg("c")
        .arg("-")
        .arg("-fsyntax-only")
        .stdin(Stdio::piped())
        .stderr(Stdio::null())
        .stdout(Stdio::null())
        .spawn()
        .with_context(|| "failed to spawn compiler for feature test")?;

    cmd.stdin
        .as_mut()
        .unwrap()
        .write_all(test_code.as_bytes())
        .with_context(|| "failed to write test code")?;

    Ok(cmd
        .wait()
        .with_context(|| "failed to wait on cc command")?
        .success())
}

fn gen_config_file(config_dir: &Path) -> Result<()> {
    let config_h = config_dir.join("picolibc.h");

    let mut file = fs::File::create(&config_h)
        .with_context(|| format!("Could not create config file {:?}", config_h))?;

    writeln!(file, "/* Generated by hyperlight build script */")?;
    writeln!(file, "#pragma once")?;
    writeln!(file)?;

    writeln!(file, "#define _NEWLIB_VERSION \"4.3.0\"")?;
    writeln!(file, "#define __NEWLIB_VERSION__ \"4.3.0\"")?;
    writeln!(file, "#define __NEWLIB__ 4")?;
    writeln!(file, "#define __NEWLIB_MINOR__ 3")?;
    writeln!(file, "#define __NEWLIB_PATCHLEVEL__ 0")?;
    writeln!(file, "#define __PICOLIBC_VERSION__ \"1.8.10\"")?;
    writeln!(file, "#define __PICOLIBC__ 1")?;
    writeln!(file, "#define __PICOLIBC_MINOR__ 8")?;
    writeln!(file, "#define __PICOLIBC_PATCHLEVEL__ 10")?;
    writeln!(file)?;

    // Static configuration
    writeln!(file, "#define __ASSERT_VERBOSE")?;
    writeln!(file, "#define __SINGLE_THREAD")?; // -Dsingle-thread=true
    writeln!(file, "#define __GLOBAL_ERRNO")?; // -Dnewlib-global-errno=true
    writeln!(file, "#define __INIT_FINI_ARRAY")?; // -Dinitfini-array=true
    writeln!(file, "#define __TINY_STDIO")?; // -Dtinystdio=true
    writeln!(file, "#define __IO_DEFAULT 'd'")?; // -Dformat-default=d (full printf functionality)
    writeln!(file, "#define __IO_FLOAT_EXACT")?; // tinystdio default
    writeln!(file, "#define __IO_WCHAR")?; // -Dio-wchar=true
    writeln!(file, "#define __IEEE_LIBM")?; // math library without errno
    writeln!(file, "#define __FAST_STRCMP")?; // default optimization
    writeln!(file, "#define __PICO_EXIT")?; // picoexit enabled by default
    writeln!(file, "#define __FAST_BUFIO")?; // -Dfast-bufio=true

    // tinystdio-specific settings
    writeln!(file, "#define __IO_SMALL_ULTOA")?; // avoid division in conversion

    for test in &[
        "__builtin_alloca",
        "__builtin_ffs",
        "__builtin_ffsl",
        "__builtin_ffsll",
        "__builtin_ctz",
        "__builtin_ctzl",
        "__builtin_ctzll",
        "__builtin_copysign",
        "__builtin_copysignl",
        "__builtin_isinf",
        "__builtin_isinfl",
        "__builtin_isnan",
        "__builtin_isnanl",
        "__builtin_isfinite",
        "__builtin_finitel",
        "__builtin_issignalingl",
        "__builtin_expect",
        "__builtin_complex",
        "__builtin_add_overflow",
        "__builtin_mul_overflow",
    ] {
        let code = format!(
            r#"
            #if __has_builtin({test})
            int main() {{ return 0; }}
            #else
            #error "Builtin not supported"
            #endif
        "#
        );

        let has = if detect_cc_feature(&code)? { 1 } else { 0 };
        writeln!(
            file,
            "#define __HAVE_BUILTIN_{} {has}",
            test.trim_start_matches("__builtin_").to_uppercase()
        )?;
    }

    let code = r#"_Complex double x = 1.0 + 2.0*I; int main() { return 0; }"#;
    let has = if detect_cc_feature(code)? { 1 } else { 0 };
    writeln!(file, "#define __HAVE_COMPLEX {has}")?;

    let code = r#"long long x = 0; int main() { return 0; }"#;
    let has = if detect_cc_feature(code)? { 1 } else { 0 };
    writeln!(file, "#define __IO_LONG_LONG {has}")?;

    // Static undefs
    writeln!(file, "#undef __ARM_SEMIHOST")?; // -Dsemihost=false
    writeln!(file, "#undef __SEMIHOST")?; // -Dsemihost=false
    writeln!(file, "#undef __THREAD_LOCAL_STORAGE")?; // -Dthread-local-storage=false
    writeln!(file, "#undef __THREAD_LOCAL_STORAGE_API")?;
    writeln!(file, "#undef __THREAD_LOCAL_STORAGE_RP2040")?;
    writeln!(file, "#undef __THREAD_LOCAL_STORAGE_STACK_GUARD")?;
    writeln!(file, "#undef __NANO_MALLOC")?; // -Dnewlib-nano-malloc=false
    writeln!(file, "#undef __NANO_MALLOC_CLEAR_FREED")?;
    writeln!(file, "#undef __MB_CAPABLE")?; // no multibyte support
    writeln!(file, "#undef __HAVE_FCNTL")?; // freestanding environment
    writeln!(file, "#undef __STDIO_LOCKING")?; // single-thread
    writeln!(file, "#undef __IO_C99_FORMATS")?; // -Dio-c99-formats=false
    writeln!(file, "#undef __IO_LONG_DOUBLE")?; // not enabled
    writeln!(file, "#undef __IO_LONG_LONG")?; // minimal format
    writeln!(file, "#undef __IO_MINIMAL_LONG_LONG")?;
    writeln!(file, "#undef __IO_PERCENT_B")?; // not enabled
    writeln!(file, "#undef __IO_PERCENT_N")?; // not enabled
    writeln!(file, "#undef __IO_POS_ARGS")?; // not enabled
    writeln!(file, "#undef __MATH_ERRNO")?; // IEEE math only
    writeln!(file, "#undef __OBSOLETE_MATH")?;
    writeln!(file, "#undef __OBSOLETE_MATH_DOUBLE")?;
    writeln!(file, "#undef __OBSOLETE_MATH_FLOAT")?;
    writeln!(file, "#undef __PREFER_SIZE_OVER_SPEED")?; // release build
    writeln!(file, "#undef __ATOMIC_UNGETC")?; // single-thread
    writeln!(file, "#undef __IEEEFP_FUNCS")?;
    writeln!(file, "#undef __INIT_FINI_FUNCS")?; // using INIT_FINI_ARRAY instead
    writeln!(file, "#undef __HAVE_BITFIELDS_IN_PACKED_STRUCTS")?;

    Ok(())
}

fn cc_build(picolibc_dir: &PathBuf, target: &str) -> Result<cc::Build> {
    let mut build = cc::Build::new();
    let compiler = env::var("HYPERLIGHT_GUEST_clang").unwrap_or("clang".to_string());

    build.compiler(compiler).std("c18").opt_level(3);

    build
        .flag("-fPIC")
        .flag("-nostdlib")
        .flag("-ffreestanding")
        .flag("-fno-common")
        .flag("-fno-builtin")
        .flag("-fdiagnostics-color=always")
        .flag("-fno-common")
        .flag("-Wall")
        .flag("-Winvalid-pch")
        .flag("-Wno-unused-command-line-argument")
        .flag("-Wno-unsupported-floating-point-opt")
        .flag("-Wextra")
        // We don't support stack protectors at the moment, but Arch Linux clang
        // auto-enables them for -linux platforms, so explicitly disable them.
        .flag("-fno-stack-protector")
        .flag("-fstack-clash-protection")
        .flag("-mstack-probe-size=4096")
        // We don't use a different stack for all interrupts, so there
        // can be no red zone
        .flag("-mno-red-zone")
        // This is a terrible hack, because
        // - we need stack clash protection, because we have put the
        //   stack right smack in the middle of everything in the guest
        // - clang refuses to do stack clash protection unless it is
        //   required by a target ABI (Windows, MacOS) or the target is
        //   is Linux or FreeBSD (see Clang.cpp RenderSCPOptions
        //   https://github.com/llvm/llvm-project/blob/1bb52e9/clang/lib/Driver/ToolChains/Clang.cpp#L3724).
        //   Hopefully a flag to force stack clash protection on generic
        //   targets will eventually show up.
        .flag("--target=x86_64-unknown-linux-none");

    build
        .flag_if_supported("-fdirect-access-external-data")
        .flag_if_supported("-frounding-math")
        .flag_if_supported("-fsignaling-nans")
        .flag_if_supported("-fno-builtin-copysignl");

    build
        .define("_FORTIFY_SOURCE", None)
        .define("ABORT_PROVIDED", "1")
        .define("DEFINE_MEMALIGN", "1")
        .define("DEFINE_POSIX_MEMALIGN", "1")
        .define("_LIBC", None)
        .define("_FILE_OFFSET_BITS", "64");

    // TODO: this is wrong, it should generate config file to out_dir/include
    // but how downstream crates get at it then? And TBH I think having piclibc
    // headers (features.h) depend on a build time header is wrong is odd to say
    // at least.
    gen_config_file(&picolibc_dir.join("newlib/libc/include"))?;

    match target {
        "x86" | "x86_64" => {
            build.include(picolibc_dir.join("newlib/libm/machine/x86"));
            build.include(picolibc_dir.join("newlib/libc/machine/x86"));
        }
        arch => {
            bail!("Unsupported target architecture: {arch}");
        }
    }

    build
        .include(picolibc_dir)
        .include(picolibc_dir.join("newlib/libc/tinystdio"))
        .include(picolibc_dir.join("newlib/libc/locale"))
        .include(picolibc_dir.join("newlib/libc/include"));

    Ok(build)
}

fn add_libc(build: &mut cc::Build, picolibc_dir: &Path, target: &str) -> Result<()> {
    let base = LIBC_FILES.iter();
    let files = match target {
        "x86" | "x86_64" => base.chain(LIBC_FILES_X86.iter()),
        arch => bail!("Unsupported target architecture: {arch}"),
    };

    for file in files {
        let source_path = picolibc_dir.join("newlib/libc").join(file);
        build.file(&source_path);
    }

    build.file("c/clock.c");
    Ok(())
}

fn add_libm(build: &mut cc::Build, picolibc_dir: &Path, target: &str) -> Result<()> {
    build.include(picolibc_dir.join("newlib"));
    build.include(picolibc_dir.join("newlib/libm/common"));

    let base = LIBM_FILES.iter();
    let files = match target {
        "x86" | "x86_64" => base.chain(LIBM_FILES_X86.iter()),
        arch => bail!("Unsupported target architecture: {arch}"),
    };

    for file in files {
        let source_path = picolibc_dir.join("newlib/libm").join(file);
        build.file(&source_path);
    }

    Ok(())
}

fn cargo_main() -> Result<()> {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=third_party/picolibc");
    println!("cargo:rerun-if-env-changed=HYPERLIGHT_GUEST_TOOLCHAIN_ROOT");

    let out_dir = env::var("OUT_DIR").expect("cargo OUT_DIR not set");
    let target = env::var("CARGO_CFG_TARGET_ARCH").expect("cargo TARGET_ARCH not set");

    let include_dir = PathBuf::from(&out_dir).join("include");
    fs::create_dir_all(&include_dir)
        .with_context(|| format!("Could not create include dir {include_dir:?}"))?;

    if cfg!(feature = "libc") {
        if !Path::new("third_party/picolibc/COPYING.picolibc").exists() {
            eprintln!("Setting up submodules");

            let mut cmd = Command::new("git")
                .arg("submodule")
                .arg("update")
                .arg("--init")
                .spawn()
                .with_context(|| "failed to spawn git submodule command")?;

            cmd.wait()
                .with_context(|| "failed to wait on git submodule command")?;
        }

        let picolibc_dir = PathBuf::from("third_party/picolibc");
        let mut build = cc_build(&picolibc_dir, &target)?;

        add_libc(&mut build, &picolibc_dir, &target)?;
        add_libm(&mut build, &picolibc_dir, &target)?;

        if cfg!(windows) {
            unsafe { env::set_var("AR_x86_64_unknown_none", "llvm-ar") };
        }

        build.compile("hyperlight_guest_bin");
        copy_includes(&include_dir, "third_party/picolibc/newlib/libc/include")?;
    }

    let include_str = include_dir
        .to_str()
        .with_context(|| "out dir include dir was not valid utf-8")?;

    println!("cargo::metadata=include={}", include_str);

    /* Correctly setting up the libc include paths for downstream
     * libraries which depend on -sys packages which need to build C
     * libraries is surprisingly difficult. Ideally, we would
     * eventually build and publish clang toolchains targeting
     * hyperlight directly, but until then we need a way for
     * downstream crates to get at the include files in this crate.
     * Copying them into our output directory, using `links = "c"`
     * (since we're libc), and using cargo metadata keys (as we have
     * just done above) mostly works for crates whose build scripts we
     * control. However, since our downstreams might also need to use
     * -sys packages that have their own detection logic (in
     * cc-rs/bindgen/clang-sys/etc), it would be nice to provide a
     * wrapped version of clang that searches all the correct include
     * paths. (Downstream crates also can't just use
     * BINDGEN_EXTRA_CLANG_ARGS="--sysroot ..." or similar, since the
     * include directory that we generate in this script ends up in
     * target/build under some unpredictable name). Cargo doesn't
     * (yet) give us an easy way to provide binaries that downstream
     * crates can use at build time, so we do an extremely ugly thing
     * here and simply write wrapper binaries into wherever an env var
     * set by downstream tells us to. Because we don't have an easy
     * way to build binaries for the host target when the library is
     * being cross-built, we do an even uglier thing and simply use
     * this build script as a multi-call binary to be those
     * wrappers. We should revisit this approach as relevant cargo
     * features like -Zartifact-dependencies, -Zout-dir,
     * -Zforced-target, etc. are stabilised, or if we decide to
     * publish a proper sysroot when the cbindgen C API is ready.
     *
     * Since we're already doing this for clang, we take advantage of
     * the same approach to provide the ml64.exe binary that cc-rs is
     * hardcoded to look for when assembling targeting msvc targets.
     * On linux, ml64.exe doesn't exist, so we replace it with a
     * wrapper that calls the compatible llvm-ml -m64.
     *
     * In general, to take advantage of this, a downstream binary
     * crate needs to:
     * - Set HYPERLIGHT_GUEST_TOOLCHAIN_ROOT to somewhere sensible
     * - Ensure that other packages look for relevant binaries in that
     *   directory, e.g. by setting CLANG_PATH for clang-sys's include
     *   path autodetection logic (used by bindgen).
     * - Ensure that hyperlight-guest is built before any packages
     *   which might need to use the toolchain, even if they don't
     *   directly depend on it, e.g. by running `cargo build -p
     *   hyperlight-guest` before building anything else.
     */
    if let Ok(binroot) = env::var("HYPERLIGHT_GUEST_TOOLCHAIN_ROOT") {
        let binroot = PathBuf::from(binroot);
        let binpath = env::current_exe().expect("couldn't get build script path");
        fs::create_dir_all(&binroot)
            .unwrap_or_else(|e| panic!("Could not create binary root {:?}: {}", &binroot, e));
        fs::write(binroot.join(".out_dir"), out_dir).expect("Could not write out_dir");
        fs::copy(&binpath, binroot.join("clang")).expect("Could not copy to clang");
        fs::copy(&binpath, binroot.join("clang.exe")).expect("Could not copy to clang.exe");
    }

    Ok(())
}

#[derive(PartialEq)]
enum Tool {
    CargoBuildScript,
    Clang,
}

impl From<&std::ffi::OsStr> for Tool {
    fn from(x: &std::ffi::OsStr) -> Tool {
        if x == "clang" || x == "clang.exe" {
            Tool::Clang
        } else {
            Tool::CargoBuildScript
        }
    }
}

fn find_next(root_dir: &Path, tool_name: &str) -> PathBuf {
    if let Some(path) = env::var_os(format!("HYPERLIGHT_GUEST_{tool_name}")) {
        return path.into();
    }

    let path = env::var_os("PATH").expect("$PATH should exist");
    let paths: Vec<_> = env::split_paths(&path).collect();
    for path in &paths {
        let abs_path = fs::canonicalize(path);
        /* since path entries may not exist (especially on Windows),
         * use the original if there are any errors. */
        let abs_path = abs_path.as_ref().unwrap_or(path);
        if abs_path == root_dir {
            continue;
        }
        let base_path = path.join(tool_name);
        if base_path.exists() {
            return base_path;
        }
        let exe_path = base_path.with_extension("exe");
        if exe_path.exists() {
            return exe_path;
        }
    }
    panic!("Could not find another implementation of {}", tool_name);
}

fn main() -> std::process::ExitCode {
    let exe = env::current_exe().expect("expected program name");
    let name = Path::file_name(exe.as_ref()).expect("program name should not be directory");
    let tool: Tool = name.into();

    if tool == Tool::CargoBuildScript {
        if let Err(err) = cargo_main() {
            eprintln!("{:#}", err);
            return std::process::ExitCode::FAILURE;
        }
        return std::process::ExitCode::SUCCESS;
    }

    let exe_abs = fs::canonicalize(&exe).expect("program name should be possible to canonicalize");
    let root_dir = exe_abs
        .parent()
        .expect("program name should be in a directory");
    let out_dir = std::fs::read_to_string(root_dir.join(".out_dir"))
        .expect(".out_dir should have a valid path in it");
    let mut args = env::args();
    args.next(); // ignore the exe name
    let include_dir = <String as AsRef<Path>>::as_ref(&out_dir).join("include");

    match tool {
        Tool::CargoBuildScript => unreachable!("cargo build script should not be called directly"),
        Tool::Clang => {
            std::process::Command::new(find_next(root_dir, "clang"))
                // terrible hack, see above
                .arg("--target=x86_64-unknown-linux-none")
                .args([
                    // We don't support stack protectors at the moment, but Arch Linux clang
                    // auto-enables them for -linux platforms, so explicitly disable them.
                    "-fno-stack-protector",
                    "-fstack-clash-protection",
                    "-mstack-probe-size=4096",
                    "-mno-red-zone",
                ])
                .arg("-nostdinc")
                .arg("-isystem")
                .arg(include_dir)
                .args(args)
                .status()
                .ok()
                .and_then(|x| (x.code()))
                .map(|x| (x as u8).into())
                .unwrap_or(std::process::ExitCode::FAILURE)
        }
    }
}
